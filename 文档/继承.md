# 20220916

## P127 类和对象-继承-基本语法

**继承是面向对象的三大特性之一**

有些类与类之间的存在特殊的关系，例如下图中：

![image-20220916193720813](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220916193720813.png)

我们发现，定义这些类时，下级别的成员除了拥有上一级的共性，还有自己的特性。

这个时候我们就可以利用继承的技术，减少重复代码。

**总结：**

继承的好处： 可以减少重复的代码

```c++
class A: public B;
```
A类称为子类或派生类
B类称为父类或基类

派生类中的成员，包含两大部分：
一类是从基类继承过来的，一类是自己增加的成员。
从基类继承过来的表现其功效，而新增的成员体现了个性。

# 20220917

## P128 类和对象-继承-继承方式

继承的语法： class 子类： 继承方式 父类

**继承的方式一共有三种：**

- 公共继承
- 保护继承
- 私有继承

![QQ图片20220917073446](./继承.assets/QQ图片20220917073446.png)

**公共继承**：
能继承父类的public、protected 权限的成员.不能继承父类的private成员

且父类中的public属性到了子类中依然是public。父类中的protected属性到了子类中依然是protected属性

**保护继承**

能继承父类的public、protected 权限的成员.不能继承父类的private成员

且父类中的public和protected成员到了子类中全都变成protected成员

**私有继承**

能继承父类的public、protected 权限的成员.不能继承父类的private成员

且父类中的public和protected成员到了子类中全都变成private成员

# 20220920

## P129 类和对象-继承-继承中的对象模型

从父类继承过来的的成员，那些属于子类对象中？

父类中所有非静态成员属性都会被继承下去（包括private成员）
父类中私有属性，被编译器隐藏了，因此访问不到，但是确实被继承下去了。

## P130 类和对象-继承-构造和析构顺序

子类继承父类后，当创建子类对象，也会调用父类的构造函数。

问题：父类和子类的构造和析构顺序是谁先谁后？

**父类构造函数 -> 子类构造函数 -> 子类析构函数 -> 父类析构函数**

因为局部变量存储在栈区上，栈区的特点是，先进后出
所以Base4类构造函数最先调用，Base4析构函数最后调用

## P131 类和对象-继承-同名成员处理

问题：当子类与父类出现同名的成员，如何通过子类对象访问到子类或父类中的同名数据呢？

- 访问子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域
- 当子类与父类拥有同名的成员函数，子类会隐藏父类中同名成员函数，加作用域可以访问到父类中同名成员函数。



# 20220921

## P132 类和对象-继承-同名静态成员处理

问题：继承中同名的静态成员变量在子类对象上如何进行访问？

静态成员和非静态成员出现同名，处理方式一致。

- 静态子类同名成员 直接访问即可
- 访问父类同名成员 需要加作用域

总结：同名静态成员处理方式和非静态处理方式一样，只不过有两种访问的方式（通过对象和通过类名）

# 20220922

## P133 类和对象-继承-多继承语法

C++允许一个类继承多个类

语法：`class 子类: 继承方式 父类1, 继承方式 父类2...`

**多继承可能会引发父类中有同名成员出现，需要加作用域区分。**

**C++实际开发中不建议用多继承**



子类占用内存空间是两个父类 + 子类本身 所占空间

![image-20220922081120799](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922081120799.png)

## P134 类和对象-继承-菱形继承

菱形继承概念：
两个派生类继承同一个基类
又有某个类同时继承这两个派生类
这种继承方式被称为菱形继承，或者钻石继承。

典型的菱形继承案例：

![image-20220922081807835](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922081807835.png)

**菱形继承问题：**
1、羊继承了动物了数据，驼同样继承了动物的数据，当羊驼使用数据时，就会产生二义性
2、羊驼继承了自动物的数据继承了两份，其实我们应该清楚，这份数据我们只需要一份就可以了。



解决方案：使用虚继承

给两个父类加上 `virtual` 关键字（注意，**两个父类都要加 virtual**）

![image-20220922084153954](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922084153954.png)

![image-20220922082754456](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922082754456.png)

使用了虚继承后，就只有一份数据了。

vbptr的意思：虚基类指针(virtual base  pointer)。虚基类指针会指向 vbtable(virtual base table) 虚基类表。

![image-20220922083346988](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922083346988.png)

也就是说，sheep类和tuo类 都通过指针，指向 动物类 的内存。

![image-20220922083839036](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922083839036.png)

但是这导致了**占用内存空间增大**。使用虚继承前，子类内存空间占8，使用虚继承后，子类内存空间占12。因为多搞了一份用来

![image-20220922084005583](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922084005583.png)

![image-20220922083948789](F:\workspace\c++\learnCPrime\文档\继承.assets\image-20220922083948789.png)

